# Dynamic Scheme Language Documentation

This is an informal document specifying the differences between RSR7-small scheme
and Dynamic Scheme.

## Differences with RSR7 scheme

Dynamic Scheme tries to resemble RSR7-small scheme as much as possible. Naming of functions
and special forms should be the same whenever possible. Dynamic Scheme changes RSR7 by adding new primitives
and evaluation rules. These new primitives are then used to implement much of the RSR7 specification. In this
manner most of the standard library can be implemented directly inside scheme.

The major changes can be summarized as follows:

* Explicit access to `*environment*`
* Dynamically scoped function and functional expressions as basic primitives of programs
* A new evaluation rule whenever a pair is in a call position


### Explicit access to the current environment

Informally speaking the environment is a data structures that keeps track of the values symbols evaluate to.

The environment is of type vector. Where each vector element is a hash table.
Since RSR7-small Scheme lacks a hash table type, we will make use of SRFI 69.

The current environment is a accessible through the `*environment*` global
variable (but is read-only?). The environment can only be changed using the 
evaluation rules explained below.


### Dynamically scoped primitives

A primitive is a Scheme construct that cannot be expressed using any other
scheme constructs (including other primitives).

The Scheme primitives can be roughly divided in control flow primitives and primitives that are specific to a data structure (for example; `string-append`).

The following are _all_ available control flow primitives.

#### (eval _expr-or-def_ _environment-specifier_)

As explained in the RSR7-small specification.

#### (fexpr (_args_ ...) _body_)

Returns a new dynamically scoped functional expression with the given arguments and body. The difference between a functional expression and a dynamic function is that the body of the former receives the arguments unevaluated. See the section on evaluation rules for more details. Note that the argument list may also be a symbol to support functional expressions with a variable number of arguments.

#### (dyn-lambda (_args_ ...) _body_)

Returns a new dynamically scoped function. Note that the argument list may also be a symbol to support functions with a variable number of arguments.

#### (if _test_ _consequent_ _alternate_)
#### (if _test_ _consequent_)

As explained in the RSR7 specification.


### Evaluation Rules

Let _v_ be a value to be evaluated.

If _v_ is a symbol, the result of is the value _v_ is mapped to in the current environment.
Else, if _v_ is not a list, the result is _v_ itself.

Else, if _v_ is a list, it might be one of the primitives detailed above. In that case the evaluation is as explained there.

Finally, if _v_ is a list but not a primitive, the first element of the list is evaluated in the current environment. It should result in either: a functional expression, a function or a pair.

* Case 1: the result is a functional expression. The arguments of the functional expression is the rest of the list. The arguments are passed _unevaluated_ to the body of the functional expression. The result is the result of the evaluation of the body.
* Case 2: the result is a function. The arguments of the function is the rest of the list. The arguments are passed _evaluated_ to the body of the function. The result is the result of the evaluation of the body.
* Case 3: If the result is a pair. The first element of the pair should be either a functional expression or a function. The second element should be an environment. The evaluation proceeds as in the previous two cases except that during the evaluation of the body the environment passed as second element is made active.




### Examples


    (define eval-nth
      (dyn-lambda (expr nth)
      	(eval expr (env-ref (+ nth 1)))))
    
    
    (define list (dyn-fun args args))
    
    
    (define f-expr-with-args
    	(dyn-lambda (args body)
    		(eval-nth (list 'fexpr args body) 1)))
    
    
    (define lambda
    	(f-expr (args body)
    		(cons
    			(f-expr-with-args arg-list body)
    			(env-ref 1))))
    
    
    
    






